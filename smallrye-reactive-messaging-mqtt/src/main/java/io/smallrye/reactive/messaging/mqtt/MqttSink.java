package io.smallrye.reactive.messaging.mqtt;

import io.netty.handler.codec.mqtt.MqttQoS;
import io.smallrye.reactive.messaging.spi.ConfigurationHelper;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.reactivex.core.Vertx;
import io.vertx.reactivex.core.buffer.Buffer;
import io.vertx.reactivex.mqtt.MqttClient;
import org.eclipse.microprofile.config.Config;
import org.eclipse.microprofile.reactive.messaging.Message;
import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;
import org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class MqttSink {

  private final String host;
  private final int port;
  private final MqttClient client;
  private final String server;
  private final String topic;
  private final int qos;

  private final SubscriberBuilder<? extends Message, Void> sink;

  public MqttSink(Vertx vertx, Config config) {
    ConfigurationHelper conf = ConfigurationHelper.create(config);
    MqttClientOptions options = new MqttClientOptions();
    options.setClientId(conf.get("client-id"));
    options.setAutoGeneratedClientId(conf.getAsBoolean("auto-generated-client-id", false));
    options.setAutoKeepAlive(conf.getAsBoolean("auto-keep-alive", true));
    options.setSsl(conf.getAsBoolean("ssl", false));
    options.setWillQoS(conf.getAsInteger("will-qos", 0));
    options.setKeepAliveTimeSeconds(conf.getAsInteger("keep-alive-seconds", 30));
    options.setMaxInflightQueue(conf.getAsInteger("max-inflight-queue", 10));
    options.setCleanSession(conf.getAsBoolean("auto-clean-session", true));
    options.setWillFlag(conf.getAsBoolean("will-flag", false));
    options.setWillRetain(conf.getAsBoolean("will-retain", false));
    options.setMaxMessageSize(conf.getAsInteger("max-message-size", -1));
    options.setReconnectAttempts(conf.getAsInteger("reconnect-attempts", 5));
    options.setReconnectInterval(TimeUnit.SECONDS.toMillis(conf.getAsInteger("reconnect-interval-seconds", 1)));
    options.setUsername(conf.get("username"));
    options.setPassword(conf.get("password"));
    options.setConnectTimeout((int) TimeUnit.SECONDS.toMillis(conf.getAsInteger("connect-timeout-seconds", 60)));
    options.setTrustAll(conf.getAsBoolean("trust-all", false));

    host = conf.getOrDie("host");
    port = conf.getAsInteger("port", options.isSsl() ? 8883 : 1883);
    server = conf.get("server-name");
    topic = conf.getOrDie("topic");
    client = MqttClient.create(vertx, options);
    qos = conf.getAsInteger("qos", 0);

    AtomicBoolean connected = new AtomicBoolean();
    sink = ReactiveStreams.<Message>builder()
      .flatMapCompletionStage(msg -> {
        // If not connected, connect
        if (connected.get()) {
          //forwarding
          return CompletableFuture.completedFuture(msg);
        } else {
          CompletableFuture<Message> future = new CompletableFuture<>();
          client.connect(port, host, server, ar -> {
            if (ar.failed()) {
              future.completeExceptionally(ar.cause());
            } else {
              connected.set(true);
              future.complete(msg);
            }
          });
          return future;
        }
      })
      .flatMapCompletionStage(msg -> {
        CompletableFuture<Integer> done = new CompletableFuture<>();
        String topic = this.topic;
        MqttQoS qos = MqttQoS.valueOf( this.qos );
        boolean isRetain = false;

        if (msg instanceof SendingMqttMessage) {
          MqttMessage mm = ((SendingMqttMessage) msg);

          topic = mm.getTopic() == null ? topic : mm.getTopic();
          qos = mm.getQosLevel() == null ? qos : mm.getQosLevel();
          isRetain = mm.isRetain();
        }

        client.publish( topic, convert( msg.getPayload() ), qos, false, isRetain, res -> {
          if ( res.failed() ) {
            done.completeExceptionally( res.cause() );
          } else {
            done.complete( res.result() );
          }
        });

        return done;
      })
      .onComplete(client::disconnect)
      .ignore();
  }

  private Buffer convert(Object payload) {
    if (payload instanceof JsonObject) {
      return new Buffer(((JsonObject) payload).toBuffer());
    }
    if (payload instanceof JsonArray) {
      return new Buffer(((JsonArray) payload).toBuffer());
    }
    if (payload instanceof String || payload.getClass().isPrimitive()) {
      return new Buffer(io.vertx.core.buffer.Buffer.buffer(payload.toString()));
    }
    if (payload instanceof byte[]) {
      return new Buffer(io.vertx.core.buffer.Buffer.buffer((byte[]) payload));
    }
    if (payload instanceof Buffer) {
      return (Buffer) payload;
    }
    if (payload instanceof io.vertx.core.buffer.Buffer) {
      return new Buffer((io.vertx.core.buffer.Buffer) payload);
    }
    // Convert to Json
    return new Buffer(Json.encodeToBuffer(payload));
  }

  public SubscriberBuilder<? extends Message, Void> getSink() {
    return sink;
  }


}
