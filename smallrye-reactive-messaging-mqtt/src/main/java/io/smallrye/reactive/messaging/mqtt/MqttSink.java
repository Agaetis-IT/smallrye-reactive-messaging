package io.smallrye.reactive.messaging.mqtt;

import io.netty.handler.codec.mqtt.MqttQoS;
import io.reactivex.FlowableSubscriber;
import io.smallrye.reactive.messaging.spi.ConfigurationHelper;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.reactivex.core.Vertx;
import io.vertx.reactivex.core.buffer.Buffer;
import io.vertx.reactivex.mqtt.MqttClient;
import org.eclipse.microprofile.reactive.messaging.Message;
import org.eclipse.microprofile.reactive.streams.CompletionSubscriber;
import org.eclipse.microprofile.reactive.streams.ReactiveStreams;
import org.reactivestreams.Subscriber;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class MqttSink {

  private final String host;
  private final int port;
  private final MqttClient client;
  private final String server;
  private final String topic;
  private final int qos;

  public MqttSink(Vertx vertx, Map<String, String> config) {
    ConfigurationHelper conf = ConfigurationHelper.create(config);
    MqttClientOptions options = new MqttClientOptions();
    options.setClientId(conf.get("client-id"));
    options.setAutoGeneratedClientId(conf.getAsBoolean("auto-generated-client-id", false));
    options.setAutoKeepAlive(conf.getAsBoolean("auto-keep-alive", true));
    options.setSsl(conf.getAsBoolean("ssl", false));
    options.setWillQoS(conf.getAsInteger("will-qos", 0));
    options.setKeepAliveTimeSeconds(conf.getAsInteger("keep-alive-seconds", 30));
    options.setMaxInflightQueue(conf.getAsInteger("max-inflight-queue", 10));
    options.setCleanSession(conf.getAsBoolean("auto-clean-session", true));
    options.setWillFlag(conf.getAsBoolean("will-flag", false));
    options.setWillRetain(conf.getAsBoolean("will-retain", false));
    options.setMaxMessageSize(conf.getAsInteger("max-message-size", -1));
    options.setReconnectAttempts(conf.getAsInteger("reconnect-attempts", 5));
    options.setReconnectInterval(TimeUnit.SECONDS.toMillis(conf.getAsInteger("reconnect-interval-seconds", 1)));
    options.setUsername(conf.get("username"));
    options.setPassword(conf.get("password"));
    options.setConnectTimeout((int) TimeUnit.SECONDS.toMillis(conf.getAsInteger("connect-timeout-seconds", 60)));
    options.setTrustAll(conf.getAsBoolean("trust-all", false));

    host = conf.getOrDie("host");
    port = conf.getAsInteger("port", options.isSsl() ? 8883 : 1883);
    server = conf.get("server-name");
    topic = conf.getOrDie("topic");
    client = MqttClient.create(vertx, options);
    qos = conf.getAsInteger("qos", 0);
  }

  public CompletableFuture<Subscriber<? extends Message>> initialize() {
    CompletableFuture<Subscriber<? extends Message>> future = new CompletableFuture<>();
    client.rxConnect(port, host, server)
      .subscribe(
        x -> {
          CompletionSubscriber<Message, Void> subscriber = ReactiveStreams.<Message>builder()
            .flatMapCompletionStage(message -> {
              CompletableFuture<Integer> done = new CompletableFuture<>();
              client.publish(topic, convert(message.getPayload()), MqttQoS.valueOf(qos), false, false, res -> {
                if (res.failed()) {
                  done.completeExceptionally(res.cause());
                } else {
                  done.complete(res.result());
                }
              });
              return done;
            })
            .ignore()
            .build();
          future.complete(subscriber);
        },
        future::completeExceptionally
      );
    return future;
  }

  private Buffer convert(Object payload) {
    if (payload instanceof JsonObject) {
      return new Buffer(((JsonObject) payload).toBuffer());
    }
    if (payload instanceof JsonArray) {
      return new Buffer(((JsonArray) payload).toBuffer());
    }
    if (payload instanceof String || payload.getClass().isPrimitive()) {
      new Buffer(io.vertx.core.buffer.Buffer.buffer(payload.toString()));
    }

    // Convert to Json
    return new Buffer(Json.encodeToBuffer(payload));
  }


  /**
   * Testing purpose only.
   * @return
   */
  public Subscriber<? extends Message> getSubscriber() {
    return initialize().join();
  }

  // TODO Disconnect


}
